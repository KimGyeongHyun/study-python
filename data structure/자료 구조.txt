storage
    데이터를 영구적으로 저장하는 곳
    데이터 이동 느림

memory
    데이터가 임시로 저장되는 곳
    테이터 이동 빠름
    (동영상 재생 시 storage 에서 memory 로 올림)

자료 구조는 데이터를 메모리에서 잘 활용하는 방법


RAM(Random Access Memory) : 임의 접근 메모리
    임의 접근 : 저장 위치 알면 접근할 때 항상 일정한 시간이 걸림 O(1)
    순차 접근 : 저장된 위치까지 가는데 한 단계씩 거쳐야 함

    임의 접근이 효율적


reference : 데이터에 접근할 수 있게 해주는 값
(주소보다 포괄적인 표현)

파이썬에서 리스트는 리스트 메모리에 실제 변수를 저장하는 c와 다르게 레퍼런스를 가짐
즉 다양한 형식의 변수(의 레퍼런스)를 추가하고 삭제할 수 있음


배열 접근 연산
    특정 위치에 저장한 데이터를 가지고 오거나 바꿔주는 연산


배열 탐색
    선형 탐색 : ~ O(n)


정적 배열 : 크기 고정
동적 배열 : 크기 변함
    꽉 찰 때마다 크기 늘림


추가 연산 (append operation) (리스트에 추가)
    1. 정적 배열 남는 공간 있을 때 O(1)
    2. " 꽉 찾을 때
        n개의 값 복사해서 붙혀 넣어야 함 O(n)

    시간복잡도는 보통 최악의 상황으로 계산
    보통 배열에 내부공간이 있고, 꽉 차서 O(n)이 되는 경우는 드물다
    비합리적인 계산으로 보임

    분할 상환 분석 (Amortized Analysis)
        시간복잡도를 최악 대신 평균으로 냄
        (동작 한 번 하는 데 걸리는 시간을 평균으로 계산)

ex) 동적 배열에 n개의 요소 추가

    (분할 상환 분석으로 보기)
    요소 추가를 n번 하니 O(n)
    배열 확장은 1, 2, 4, 8 씩 복사 (그만큼의 시간 들어감)
    가장 마지막에 데이터를 m개 옮겨서 저장 가정 (m 은 2의 배수)
    복사, 저장 시간 : m + m/2 + m/4 ... = 2m-1
    m < n 임
    즉 복사, 저장 시간은 2n 보다 적음
    총 합은 3n 보다 적은 시간 -> O(n)
    추가 연산 n 번 -> O(n)   /   추가 연산 1 번 -> O(n)/n = O(1)

    즉 추가 연산할 때 최악의 경우 -> O(n), 분할 상환 분석 -> O(1)


삽입 연산(insert operation) (아무 위치에 삽입)
    1. 정적 배열에 남는 공간 있을 때
        해당 인덱스 기준 요소들 뒤로 밀어서 저장
        최악의 경우 O(n) (index 0에 들어가는 경우)

    2. " 꽉 찼을 때
        새로운 배열 만듦
        복사, 저장  O(n)
        해당 인덱스 기준 요소들 뒤로 밀어서 저장
        최악의 경우 O(n) (index 0에 들어가는 경우)
        최종적으로 O(n)

    결국 시간복잡도는 O(n)


삭제 연산 동작 (임의의 요소 삭제)
    해당 인덱스 기준 요소들 앞으로 당겨서 저장
    최악의 경우 O(n) (index 0인 경우)
    최적의 경우 O(1) (마지막일 경우)

    삭제 시 동적 배열 크기 줄이기도 함
        특정 조건(1/3로 줄어든 경우) 만족하면 새로운 배열 정의 후 복사, 저장 O(n)
        하지만 분할 상환 분석으로 볼 경우 데이터 (1개) 삭제 연산도는 O(1)


동적 배열 낭비되는 공간복잡도 O(n)


링크드 리스트
    데이터를 순서대로 저장
    요소 추가 가능
    뒤에 붙는 요소의 이름(ref)을 저장
    실제 메모리에는 여기저기 흩어져 있음
    선형 탐색의 특성

    노드는 2가지 속성
        1. data : 저장하고 싶은 값
        2. next : 다음 노드에 대한 reference

        첫번째 노드는 head node

    접근 연산
        특정 위치에 있는 노드를 리턴하는 연산
        링크드 리스트는 한 번에 접근 불가능
        인덱스 만큼 이동해야 함 O(n)

    탐색 O(n)

    삽입/삭제
        이 경우 주변 노드 레퍼런스만 수정하므로 O(1)
        하지만 해당 노드 레퍼런스를 먼저 찾아야 하므로 O(n)
        즉 최종 시간복잡도는 O(n)
        반면 head, tail 의 경우 한 번에 찾을 수 있으므로 O(1)
        (가장 뒤에 노드 삭제는 뒤에서 두 번째 노드에 접근하므로 이므로 이 경우에만 O(n))


더블리 링크드 리스트
    싱글리 링크드 리스트와 비교하여 prev 추가

    접근/탐색은 O(n) 으로 동일
    삽입/삭제는 O(1)
    하지만 해당 노드 레퍼런스를 먼저 찾아야 하므로 O(n)
    즉 최종 시간복잡도는 O(n)
    반면 가장 앞, 뒤의 접근, 삭제는 O(1)
    싱글리 링크드와 비교하여 가장 뒤에 노드 삭제의 시간복잡도가 다름

    tail 노드를 많이 삭제해야 된다면 더블리 링크드 리스트가 효율적


key-value 데이터
    하나의 key 당 하나의 value 만 존재
    key를 인덱스라고 생각하며 사용 -> Direct Access Table 방식
    공간의 낭비가 심함

해시 함수
    특정 값을 원하는 범위의 자연수로 바꿔주는 함수
    - 한 해시 테이블의 해시 함수는 결정론적이어야 함 (같은 key에 같은 결과)
    - 결과 해시값이 치우치지 않고 고르게 나와야 함
    - 빨리 계산되어야 함

    ex) 나누기 방법
        배열의 크기로 나눠서 나머지 리턴

    ex) 곱셈 방법
        0 < a < 1 값에 key를 곱하고 소수점 버림
        (소수점 버릴 시 원하는 범위의 자연수 구할 수 있음)
        배열의 크기를 곱하고 소수점 버리고 리턴

    파이썬에서 지원하는 해시 함수의 경우 숫자 뿐만 아니라
    다른 형식(문자열, 불린, 튜플)의 key 도 지원

해시 테이블
    원하는 크기의 배열 만듦
    key를 해시 함수로 해당 배열의 인덱스로 전달
    한 인덱스(배열)에 key, value 동시에 넣음

    이미 사용하고 있는 인덱스에 새로운 key, value 들어오는 경우
    충돌(collision)이 일어났다 라고 표현
    1. Chaining
        배열 인덱스에 링크드 리스트 저장해서 충돌 해결
    2. Open Addressing
        비어있는 다른 인덱스를 찾아 저장해서 충돌 해결

Chaining

    연산
    1.탐색
        주어진 key 에 해당한 value 리턴

        해시 함수(O(1))를 통해 배열의 인덱스 접근(O(1))
        링크드 리스트를 하나씩 돌면서 원하는 키가 나올 때까지 반복, 리턴 (O(n))
        총 시간복잡도 O(n)

    2. 삽입
        해시 함수(O(1))를 통해 배열의 인덱스 접근(O(1))
        링크드 리스트를 하나씩 돌면서 원하는 키가 나올 때까지 반복 (O(n))
        (탐색 없이 바로 삽입하면 하나의 key 에 여러개의 value 들어갈 수 있음)
        같은 키가 있다면 새로운 node 로 바꿈 (O(1))
        같은 키가 없다면 새로운 node 추가 (O(1))
        총 시간복잡도 O(n)

    3. 삭제
        해시 함수(O(1))를 통해 배열의 인덱스 접근(O(1))
        링크드 리스트를 하나씩 돌면서 원하는 키가 나올 때까지 반복 (O(n))
        같은 키가 있다면 삭제 (O(1))
        총 시간복잡도 O(n)

    연산의 경우 불공평한 시간복잡도 나옴
    링크드 리스트의 평균길이는
    해시 테이블에 총 들어가 있는 key-value 쌍의 수: n
    해시 테이블이 사용하는 배열의 크기: m 이라고 한다면
    n/m 으로 볼 수 있음
    key-value 쌍의 수가 배열의 크기보다 작거나 같다고 가정하면
    n/m <= 1
    시간복잡도는 O(1)
    대부분의 경우 O(1)이 걸린다고 가정하고 사용
    최악 O(n), 평균 O(1)


Open Addressing

    선형 탐사 : 충돌 일어났을 때, 한 칸씩 다음 인덱스가 비었는지 확인
    제곱 탐사 : 한 칸씩이 아니라 1부터 시작하는 정수의 제곱의 합의 인덱스 확인

    탐색/삭제 (선형)
        중간 index 에 값이 없다면 다른 해시값임
        즉 중간의 index 지점을 삭제한다면 해당 지점에 "DELETED" 저장

    탐색 -> 최악 n개가 모두 한 해시값 안에 있는 경우 O(n)
    삽입, 삭제도 마찬가지지

    평균 시간 복잡도
        m : 배열 크기
        n : 해시 테이블 안 데이터 쌍 수
        해시 테이블이 얼마나 차 있나 a = n/m (load factor)
        load factor 는 1보다 작다 가정
        평균 탐사 시간 = 1/(1-a) (수학적 도출)
        보통 load factor 는 작음 (0.9 정도로 커지지 않음)
        load factor 가 크다고 보고 a = 1/2 로 가정, 평균 탐사 시간은 2
        load factor 가 0.9 이하라고 약속하면
        평균 탐사 시간은 10 이하 즉 O(1)

        탐색, 삽입, 삭제 모드 O(1)


추상 자료형 (Abstract Data Type)
    기능: 연산이 "무엇"을 하는지
    구현: 연산의 기능을 "어떻게" 하는지

    추상 자료형
        자료 구조를 추상화
        데이터를 저장/사용할 때 기능만 생각 (구현 X)
        기능에만 집중, 코드의 흐름에 집중 가능

    자료 구조: 기능뿐만 아니라 구현까지 포함한 내용
    추상 자료형은 기능만 생각

    리스트라는 추상 자료형을
    동적 배열이나, 링크드 리스트라는 자료 구조로 구현함

    파이썬은 추상화가 많이 된 고수준 언어
    많은 자료형 이름이 추상 자료형
    기능만 알아도 사용 가능


리스트 구현
    디폴트는 동적 배열

    동적 배열 vs 더블리 링크드 리스트

    동적 배열: 접근, 맨 뒤 삽입 삭제를 분할 상환을 통해 효율적으로 함
    링크드: 처음과 끝 삽입 삭제 효율적

    접근이 많다면 동적배열, 맨 앞 삽입, 삭제가 많다면 링크드 리스트 사용

Queue (대기열)
    FIFO: First in First out 의 원칙

    연산
    - 맨 뒤 데이터 추가
    - 맨 앞 데이터 삭제, 접근

    큐는 동적 배열, 링크드 리스트 둘다 구현 가능
    맨 앞 삭제 동작은 동적 배열에서 비효율적 O(n)
    더블리 링크드 리스트는 모든 연산에 대해서 효율적 O(1)
    즉 링크드 리스트가 좋음

Stack
    LIFO 의 원칙 (마지막 데이터가 먼저 삭제)

    연산
    - 맨 뒤 데이터 추가, 삭제, 접근

    스택도 동적 배열, 링크드 리스트로 구현 가능
    맨 뒤 연산은 두 개 모두 효율적 O(1)

Dictionary (map)
    위의 추상 자료형들과 달리 데이터간 순서 관계를 약속하지 않음

    연산
    - key-value 데이터 쌍 삽입
    - key 탐색, 삭제

    해시 테이블의 경우 해당 연산과 일치하고 모든 연산이 효율적
    파이썬에서 딕셔너리는 해시 테이블로 구현되어 있음

Set (집합)
    데이터간 순서 관계 약속하지 않음

    연산
    - 삽입: 데이터를 저장할 수 있다 (중복 데이터 X)
    - 탐색: 데이터가 저장됐는지 확인할 수 있다
    - 삭제: 저장한 데이터를 지울 수 있다

    보통 해시 테이블로 구현
    인덱스에 key 만 저장
    모든 연산은 O(1)