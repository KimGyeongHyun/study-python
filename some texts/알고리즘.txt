---------------------------------------------
정렬 알고리즘
1. 선택 정렬 Selection Sort
 리스트 전체 탐색 후 최솟값 배치, 반복
 각 위치에 어떤 값이 들어갈지 찾음
2. 삽입 정렬 Insertion Sort
 리스트 앞에서부터 시작해서 이전 인덱스 리스트 비교해서 하나씩 삽입, 반복
 각 값이 어떤 위치에 들어갈지 찾음
3. 합병 정렬 Merge Sort (Divide and Conquer 사용)
 Combine 작업이 어려움
4. 퀵 정렬 (Divide and Conquer 사용)
 Divide 작업이 어려움
 divide 작업을 리스트 변수에 따라 유동적으로 함
----------------------------------------------
정렬된 리스트에서 찾는 알고리즘
1. 선형 탐색 알고리즘
 앞에서부터 찾음
2. 이진 탐색 알고리즘
 리스트 중간 업다운 판단 후 반을 날림, 반복
---------------------------------------------------


점근표기법 Big-O Notation


재귀 함수


Brute Force
모든 경우의 수를 무식하게 다 해보는 알고리즘


Divide and Conquer
 문제를 나누고, 정복하고, 합친다
 재귀함수 사용


------------------------------------------------
Dynamic programming

조건
1. 최적 부분 구조 Optimal Substructure
 부분 문제들의 최적의 답 -> 기존 문제의 최적의 답 구할 수 있다는 것
2. 중복되는 부분 문제 Overlapping Subproblems
 부분 문제들이 중복됨

계산한 결과를 재활용하는 방식
1. memoization
 중복되는 계산을 한 번만 계산 후 메모
 위에서 아래로
 재귀함수 사용
2. tabulation
 아래에서 위로 (중복되는 계산 없음)
 (예제에서는 리스트에 저장)
 반복문 사용

공간 최적화를 위해 이전에 썼던 필요없는 데이터는 버리고 활용 안 할 수 있음
----------------------------------------------------------


------------------------------------------------------------
Greedy Algorithm
 미래 X, 당장 눈 앞에 보이는 최적의 선택
 간단하고 빠르지만 최적의 답이 아닐 수 있음

아래의 두 속성을 가지고 있다면 Greedy Algorithm이 최적의 선택 보장
최적 부분 구조
탐욕적 선택 속성 (Greedy Choice Property)
 각 단계에서 탐욕스런 선택이 최종에선 최적의 선택인 경우
--------------------------------------------------------------